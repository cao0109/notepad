# 前后端的身份认证

## **1. Web 开发模式**

① 基于服务端渲染的传统 Web 开发模式 

② 基于前后端分离的新型 Web 开发模式

### 1.1 **服务端渲染的优缺点**

优点： 

① **前端耗时少。**因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。 

② **有利于[SEO](https://blog.csdn.net/whatday/article/details/86715532?ops_request_misc=&request_id=&biz_id=102&utm_term=seo&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-86715532.nonecase&spm=1018.2226.3001.4187)。**因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。 

缺点： 

① **占用服务器端资源。**即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。 

② **不利于前后端分离，开发效率低。**使用服务器端渲染，则**无法进行分工合作**，尤其对于**前端复杂度高**的项目，不利于 

项目高效开发。

### 1.2 **前后端分离**的**优缺点**

优点： 

① **开发体验好。**前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。 

② **用户体验好。**Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。 

③ **减轻了服务器端的渲染压力。**因为页面最终是在每个用户的浏览器中生成的。 

缺点： 

① **不利于 SEO。**因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方 

案：利用 Vue、React 等前端框架的 **SSR** （server side render）技术能够很好的解决 SEO 问题！）



## **2. 身份认证**

身份认证（Authentication）又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。

### 2.1 不同开发模式下的身份认证

① 服务端渲染推荐使用 **Session 认证机制** 

② 前后端分离推荐使用 **JWT 认证机制**



## **3. Session 认证机制** 

### 3.1. HTTP 协议的无状态性

HTTP 协议的无状态性，指的是客户端**的每次 HTTP 请求都是独立的**，连续多个请求之间没有直接的关系，服务器不会主动保留每次 HTTP 请求的状态。

### 3.2. 如何突破 HTTP 无状态的限制

> **Cookie技术**

#### 1.**什么是** **Cookie** 

Cookie 是**存储在用户浏览器中的一段不超过 4 KB 的字符串**。它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。 

不同域名下的 Cookie 各自独立，每当客户端发起请求时，会**自动**把**当前域名下**所有**未过期的 Cookie** 一同发送到服务器。 

**Cookie的几大特性：** 

① 自动发送 

② 域名独立 

③ 过期时限 

④ 4KB 限制

#### 2. **Cookie 在身份认证中的作用**

客户端第一次请求服务器的时候，服务器**通过响应头的形式**，向客户端发送一个身份认证的 Cookie，客户端会自动 将 Cookie 保存在浏览器中。 

随后，当客户端浏览器每次请求服务器的时候，浏览器会**自动**将身份认证相关的 Cookie，**通过请求头的形式**发送给 服务器，服务器即可验明客户端的身份。

 ![1655969992860](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655969992860.png)

#### 3.Cookie 不具有安全性

不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器

#### 4.Session 的工作原理

![1655972802472](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655972802472.png)

### 3.3 在 Express 中使用 Session 认证

#### 1. 安装express-session 中间件

> npm i  express-session 

#### 2. 配置 express-session 中间件

![1655972923805](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655972923805.png)

#### 3. 向 session 中存数据

可通过 **req.session** 来访问和使用 session 对象，从而存储用户的关键信息：

![1655972957287](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655972957287.png)

#### 4.从 session 中取数据

![1655973677187](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655973677187.png)

#### **5. 清空 session** 

![1655973725435](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655973725435.png)



## 4. JWT（JSON Web Token）认证机制

### 4.1 **Session 认证的**局限性

Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，**需要做很多额外的配置**，才能实现跨域 Session 认证。 

注意： 

⚫ 当前端请求后端接口**不存在跨域问题**的时候，**推荐使用 Session** 身份认证机制。 

⚫ 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。

### 4.2 **JWT 的**工作原理

![1655974078818](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655974078818.png)

### 4.3 JWT 的组成部分

JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。  

![1655974528871](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655974528871.png)

- **Payload** 部分**才是真正的用户信息**，是用户信息加密之后生成的字符串。 
- Header 和 Signature 是**安全性相关**的部分，只为了保证 Token 的安全性。

![1655974593376](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655974593376.png)

### 4.4 JWT 的使用方式

​	客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。
​	此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 
请求头的 Authorization 字段中，格式如下：

![1655974683466](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1655974683466.png)

### 4.5  在 Express 中使用 JWT

#### 1. 安装 JWT 相关的包

> npm i jsonwebtoken express-jwt

-  **jsonwebtoken** 用于**生成 JWT 字符串** 
-  **express-jwt** 用于**将 JWT 字符串解析还原成 JSON 对象**

#### 2.require导入

#### 3.**定义 secret 密钥**

用于**加密**和**解密**

> const secretKey = 'caoh2'

#### 4. 在登录成功后生成 JWT 字符串

调用 **jsonwebtoken** 包提供的 **sign()** 方法，将用户的信息加密成 JWT 字符串，响应给客户端：

![1656034121034](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1656034121034.png)

#### 5. 将 JWT 字符串还原为 JSON 对象

客户端每次在访问那些有权限接口的时候，都需要主动通过**请求头中的 Authorization 字段**，将 Token 字符串发 送到服务器进行身份认证。 

![1656034590827](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1656034590827.png)

#### 6. 使用 req.user 获取用户信息

当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 **req.user** 对象，来访问从 JWT 字符串中解析出来的用户信息了，示例代码如下：

![1656034815772](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1656034815772.png)

#### 7. 捕获解析 JWT 失败后产生的错误

当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串**过期**或**不合法**，会产生一个**解析失败**的错误，影响项目的正常运行。我们可以通过 **Express 的错误中间件**，捕获这个错误并进行相关的处理，示例代码如下：

![1656034852157](%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.assets/1656034852157.png)

